# Mysql

### 1. 架构 
<img src="../pictures/mysql/mysql%20architecture.png" alt="img" style="zoom:70%;" />

### 2.引擎 
<img src="../pictures/mysql/mysql%20engines.png" alt="img" style="zoom:70%;"/>

#### 2.1 MyISAM  & InnoDB区别

> 引擎查询:  `show engines;`

|              | MyISAM                                               | InnoDB                                     |
| ------------ | ---------------------------------------------------- | ------------------------------------------ |
| 事务         | ×                                                    | √                                          |
| 锁           | 表锁                                                 | 行锁                                       |
| 读写         | 相互阻塞                                             | 事务隔离级别相关                           |
| 外键约束     | ×                                                    | √                                          |
| 索引         | `全文索引`  `非聚簇索引`                             | `V5.5以上全文索引` `聚簇索引` `非聚簇索引` |
| 存储类型     | `.frm: 表定义`    `.myd: 数据文件`  `.myi: 索引文件` | 索引和数据在同一个数据文件                 |
| 性能         | 读优写差                                             | 写优                                       |
| 是否存总行数 | √                                                    | ×                                          |
| B+ 树Data域  | 磁盘地址                                             | 行记录                                     |
| 崩溃修复     | ×                                                    | √                                          |
| 回表         | √                                                    | 区分情况                                   |
| 必须主键     | ×                                                    | √                                          |

### 3. 索引

#### 3.1 索引设计思想：

> 用空间换时间，减少磁盘IO次数

#### 3.2 Mysql 数据读取

> 按页读取， 每页16K

#### 3.3 [索引分类](https://blog.csdn.net/hzether/article/details/144859053)

> **分类维度：**
>
> 按数据结构分类：B+Tree、Hash、Full-Text、R-Tree  
> 按功能分类：主键索引、唯一索引、普通索引、全文索引、组合索引  
> 按存储方式分类：聚簇索引、非聚簇索引（辅助索引）  
> 按覆盖范围分类：覆盖索引、非覆盖索引  
> 按索引列数量分：单列索引、多列索引  



|          | B+Tree                       | Hash                     | Full-Text                                | R-Tree               | 主键                           | 唯一                                   | 普通               | 组合                                 |
| -------- | ---------------------------- | ------------------------ | ---------------------------------------- | -------------------- | ------------------------------ | -------------------------------------- | ------------------ | ------------------------------------ |
| 数据结构 | B+Tree                       | Hash                     | 倒排索引                                 | R-Tree               | B+Tree                         | B+Tree                                 | B+Tree             | B+Tree                               |
| 功能     | **普通索引、<br />主键索引** | 普通索引                 | 全文索引                                 | 空间索引             | **主键索引**                   | **唯一索引**                           | 普通索引           | **普通索引**                         |
| 存储方式 | **聚簇/非聚簇**              | 非聚簇                   | 非聚簇                                   | 非聚簇               | **聚簇**                       | **非聚簇/聚簇**                        | 非聚簇             | **非聚簇**                           |
| 覆盖范围 | 覆盖/非覆盖                  | 非覆盖                   | 非覆盖                                   | 非覆盖               | 覆盖/非覆盖                    | 覆盖/非覆盖                            | 覆盖/非覆盖        | 覆盖/非覆盖                          |
| 特点     |                              |                          | 1.用于全文搜索<br />2.支持自然语言查询。 |                      | **值唯一、非空**               | **值唯一、可空**                       | **无唯一约束**     | 1.多个列索引<br />2.遵循最左前缀原则 |
| 优点     |                              | 查询速度极快             | 支持复杂文本搜索                         | 支持空间数据高效查询 | 保证数据**唯一性，查询效率高** | 保证数据**唯一性，查询效率高**         |                    |                                      |
| 缺点     |                              | **不支持范围查询和排序** | 查询性能受数据量影响                     | 使用场景有限         | 只能有一个主键索引             | **插入和更新检查唯一性**，可能影响性能 | 需要额外的存储空间 |                                      |
| 适用场景 | **等值查询、范围查询、排序** | **等值查询**             | 文本字段全文搜索                         | 地理空间数据查询     | **主键列**                     | **需要唯一性约束的列**                 | 需要加速查询的列   | 多列查询条件                         |

#### 3.4 索引数据结构

|                                     | 特点                                                         | 缺点                                                         |
|-------------------------------------| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 哈希表                                 | 增删改查效率高                                               | 1. 无序<br />2. 不支持范围查询                               |
| 二叉树                                 |                                                              | 1. 可能退化成链表<br />2. 树的深度会影响新增和查询效率，磁盘IO高 |
| 二叉平衡树                               | 左右子树高度差<=1                                            | 1. 树的深度会影响新增和查询效率，磁盘IO高                    |
| 红黑树                                 |                                                              |                                                              |
| [B 树](../pictures/mysql/B%20Tree.png)       | 0. 每个叶子节点都是一个**页(Page) / 磁盘块**<br />1. 非叶子节点数据结构**<键值Key : Data域 : 指针>** | 1. mysql 按页(16K)读取，data域占用节点存储<br />2. 查询可能需要进行向上递归查找 |
| [B+ 树](../pictures/mysql/B%20Tree%20Plus.png) | 0. 每个叶子节点都是一个**页(Page) / 磁盘块**<br />1. 非叶子节点数据结构**<键值Key : 指针>**<br />2. 非叶子节点索引也会存在子节点中<br />3. 最底叶子节点数据结构**<关键字 : 行记录>**<br />4. 最底叶子节点是连起来的**有序双向链表**（高效范围查询） |                                                              |

#### 3.5 索引覆盖

> 索引包含了（或覆盖了）满足查询语句中字段与条件的数据

#### 3.6 索引下推

> 

#### 3.7 回表

> 

#### 3.8 聚簇索引 & 非聚簇索引(辅助索引)

|            | 特点                                                         | 优点                           | 缺点                               | 适用场景                                                     |
| ---------- | ------------------------------------------------------------ | ------------------------------ | ---------------------------------- | ------------------------------------------------------------ |
| 聚簇索引   | 1. 索引和数据存储在一起，表数据按索引顺序存储。<br />2. 每张表只能有一个聚簇索引。 <br />3. 主键索引默认是聚簇索引。 | 查询效率高，<br />减少磁盘 I/O | 插入和更新时<br />可能引起数据重排 | 1. 主键索引<br />2. 唯一索引<br />(`主键不存在` & <br />`唯一列值不为空`) |
| 非聚簇索引 | 1. 索引和数据分开存储，索引中存储指向数据的指针<br />2. 每张表可以有多个非聚簇索引 |                                |                                    |                                                              |

### 4. 锁

#### 4.1 类型

| 分类 | 锁名称 | 锁名称          | 乐观 | 悲观 |                                                              |
| ---- | ------ | --------------- | ---- | ---- | ------------------------------------------------------------ |
| 粒度 | 表锁   | 意向锁(`IX/IS`) |      |      |                                                              |
|      |        | 共享锁(`S`)     | √    |      | `lock table tab_name read; (不允许使用)`                     |
|      |        | 排他锁(`X`)     |      | √    | `SELECT ... where id = '1' for update`<br />`lock table tab_name write; (不允许使用)` |
|      |        | 元数据锁        |      |      |                                                              |
|      |        | AUTO-INC        |      |      |                                                              |
|      | 行锁   | S / X           |      |      | `select id from where id = 1; (索引生效是行锁，否则表锁)`<br />`SELECT ... where id = '1' LOCK IN SHARE MODE;` |
|      | 间隙锁 | 意向锁(`IX/IS`) |      |      | `SELECT ... where id = '1' for update;`<br />解析：update 过程中会加 **行锁和 间隙锁** 对索引前后上锁，防止插入数据<br />`select ... where id > 10;`<br />解析：id大于10为间隙锁范围，防止插入数据 |

> 表锁：加锁前需要检查所有行无S 或 X Lock  
> 意向锁：意义是**防止遍历**  
> 元数据锁：表DDL时，进行insert、update、delete操作阻塞  
> 间隙锁：解决并发事务**新增或删除**数据导致的 幻读问题



#### 4.3 表锁兼容性

| 兼容性 | X(排他锁) | IX(排他意向锁) | S(共享锁) | IS(共享意向锁) |
| ------ | --------- | -------------- | --------- | -------------- |
| X      | ×         | ×              | ×         | ×              |
| IX     | ×         | √              | ×         | √              |
| S      | ×         | ×              | √         | √              |
| IS     | ×         | √              | √         | √              |

| 组合性 | X    | IX   | S    | IS   |
| ------ | ---- | ---- | ---- | ---- |
| 表锁   | √    | √    | √    | √    |
| 行锁   | √    |      | √    |      |



#### <a id="trans_selects">查询</a>

> 正在进行中的事务：`SELECT * FROM information_schema.INNODB_TRX;`  
> 正在锁的事务： `SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;`  
> 等待锁的事务：`SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;`  
> 是否锁表：`SHOW OPEN TABLES where In_use > 0;`  
> 查看最近死锁的日志：`show engine innodb status;`  

### 5. [事务](https://cloud.tencent.com/developer/article/2329939)

#### 5.0 基础概念

> **事务概念和作用**：用于保证数据的一致性，事务是在数据库管理系统中执行的一个逻辑操作单元，要么都成功，要么都失败  
> **版本链**：数据表的一行记录，所有的历史版本数据组成的链表   
> **db_row_id**：6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID生成一个聚簇索引。  
> **db_trx_id** : 6byte，事务id（transaction id： InnoDB事务更新时生成），**该编号是严格按照递增顺序产生的**  
> **db_roll_pointer**：7byte, 指向上一事务版本指针（InnoDB事务更新时生成，insert时无版本记录）  
> [**Consistent Read view**（一致性视图）](https://www.jianshu.com/p/56ad7ffc1886)  
>
> > m_ids：生成ReadView时当前系统中活跃的所有事务的事务id列表  
> > min_trx_id：生成ReadView时，m_ids中最小值  
> > max_trx_id：生成ReadView时系统中应该分配给下一个事务的id值（m_ids最大 + 1）  
> > creator_trx_id：生成该ReadView的事务的事务id   

#### 5.0 事务分类

> 隐式事务：insert、update、delete  
> 显式事务：autocommit=off，手动BEGIN、COMMIT和ROLLBACK语句来控制事务的执行

#### 5.1 原子性(Atomicity)

> 原理：通过[**Undo log**](#un-re-do-log)记录事务恢复SQL，保证原子性。  
> **记录**：buffer pool 数据页修改前，记录到undolog buffer  
> **删除**：事务提交后，通过后台purge线程进行回收  
> **写入**：在数据修改前写入   

#### 5.2 持久性(Durability)

> 原理：通过[**Redo log**](#un-re-do-log)记录事务执行过程中的修改情况，保证持久性。  
> **记录**：buffer pool 数据页变更结束后，相应修改记录到redolog buffer  
> **删除**：由后台purge线程进行回收  
> **写入**：事务提交时写入（也有可能[提交前写入](https://cloud.tencent.com/developer/article/1945809)）  

#### 5.3 隔离性(Isolation)

> **解决的问题**：多事务并发问题
> **RC && RR 隔离级别实现**: [MVCC机制](#mvcc) + 读写锁

| 隔离级别                       | 脏读 | 不可重复读 | 幻读                             |                                           |
| ------------------------------ | ---- | ---------- | -------------------------------- | ----------------------------------------- |
| 读未提交(RU, Read uncommitted) | √    | √          | √                                |                                           |
| 读已提交(RC, Read committed）  | ×    | √          | √`(通过mvcc)`                    | 每次select<br />创建新Read View           |
| 可重复读(RR, Repeatable read） | ×    | ×          | √ `(通过mvcc & 行锁+间隙锁解决)` | 事务第一次select时<br />生成一个Read View |
| 串行化（Serializable）         | ×    | ×          | × `(读数据行加读写锁)`           |                                           |

#### 5.4 一致性(Consistency)

>  通过持久性+原子性+隔离性来保证

#### 5.5 <a id ="mvcc">MVCC（多版本并发控制）</a>

>原理：
>
>> 通过**Read View**和**Undo Log版本链**及**链元素中两个隐藏列**（trx_id 和 roll_pointer）比对，  
>> 如果不满足可见行，就会顺着 undo log 版本链里找到满足其可见性的记录，  从而控制并发事务访问同一个记录时的行为。  
>
>优点：
>
>> 读写互不阻塞，提高并发性能  
>> 降低死锁风险
>
>缺点:
>
>> 不能解决幻读的问题。原因是MVCC前提是数据存在，  
>> 幻读发生在新增和删除时
>
>当前读 & 快照读
>
>|                                    | 实现原理                               | 应用                                                         |
>| ---------------------------------- | -------------------------------------- | ------------------------------------------------------------ |
>| 快照读/<br />普通度/<br />一致性读 | Consisent Read View & MVCC             | 普通不加锁的select                                           |
>| 当前读/<br />锁定读                | 读到的数据（索引记录）加共享锁或排他锁 | select ... lock in share mode;  <br />select ... for update;  <br />insert; <br />update; <br />delete; |
>|                                    |                                        |                                                              |
>

#### 5.5 <a id="un-re-do-log">UndoLog  & RedoLog 工作原理</a>

<image src="../pictures/mysql/undo redo log process.png" width="40%"/>

**Undo Log（回滚日志）**

- 原理：

  > 记录一行数据每一次更新操作产生的一个 roll_pointer 指针和一个 trx_id 事务id  
  > 变更数据格式：`|DB_ROW_ID|DB_TRX_IDS|DB_ROLL_POINTER|变更行记录|`

- 记录过程：添加log buffer记录， redolog落盘前进行刷盘

- 作用

  > **实现事务回滚，保障事务的原子性**  
  > **实现 MVCC（多版本并发控制）关键因素之一**

**Redo Log（重做日志）**



#### 5.6 UndoLog  & RedoLog & BinLog 区别





### 6. 基础使用

#### 6.1 分页查询

#### 6.2 自定义排序实现方式



### 7. 高可用方案

#### 1.分库分表

- ### Sharding - JDBC（Apache Shardingsphere）

  > - **支持特性：**
  >   SQL语法支持较多，支持分库分表、读写分离、  
  >   分布式id生成、柔性事务（最大努力送达型事务、TCC事务）。
  > - **优点：**
  >   不用部署，运维成本低，无需代理层的二次转发请求，性能很高。
  > - **缺点：**
  >   升级需要各个系统都重新升级版本再发布，  
  >   各个系统都需要耦合sharding-jdbc的依赖。

- #### [Mycat（Apache MyCAT）](http://www.mycat.org.cn/document/mycat-definitive-guide.pdf)

  数据分片存在的问题：
  
  - 多片结果汇总后limit问题
  - 关联表join问题
  
  数据切分原则：
  
  - 第一原则：能不切分尽量不要切分。
  - 第二原则：如果要切分一定要选择合适的切分规则，提前规划好。
  - 第三原则：数据切分尽量通过数据冗余或表分组（Table Group）来降低跨库Join的可能。（基于ER关系数据分片策略）
  - 第四原则：由于数据库中间件对数据Join实现的优劣难以把握，而且实现高性能难度极大，业务读取尽量少使用多表Join。
  
  分片设计原则：
  
  - 找到拆分维度
  
  - 为了规避单节点主机并发数限制，尽量将读写压力高的分片节点（dataNode）均衡的放在不同的节点主机（dataHost）  
  
  [拆分方式](https://zhuanlan.zhihu.com/p/137368446)：
  
  | 方式     | 依据 | 特点                                                         | 应用场景                                                     |
  | -------- | ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | 水平分库 | 字段 | 每个**库**的**结构**都一样； <br />每个**库**的**数据**都不一样，没有交集；<br />所有**库**的**并集**是全量数据； | 绝对并发高，使用多库缓解io和cpu压力                          |
  | 水平分表 | 字段 | 每个**表**的**结构**都一样；<br />每个**表**的**数据**都不一样，没有交集； <br />所有**表**的**并集**是全量数据； | 并发不高，拆分单表数量，减少cpu压力                          |
  | 垂直分库 | 表   | 每个**库**的**结构**都不一样； <br />每个**库**的**数据**也不一样，没有交集； <br />所有**库**的**并集**是全量数据； | 系统绝对并发量上来了，并且可以抽象出单独的业务模块           |
  | 垂直分表 | 字段 | 每个**表**的**结构**都不一样； <br />每个**表**的**数据**也不一样，一般来说，每个表的**字段**至少有一列交集，一般是主键，用于关联数据； <br />所有**表**的**并集**是全量数据； | 是将热点数据（可能会冗余经常一起查询的数据）放在一起作为主表，非热点数据放在一起作为扩展表 |
  
  
  
  - ：以字段每个库结构一样，数据不同，解决高并发，分担单节点压力
  - ：每个表结构一样，数据不同，并发不高单表数据大。导致cpu压力太大
  - ：
  - 

#### 2.读写分离

mysql 主从备份机制，master写，slave读



### 综合使用

#### 1. 性能优化

- 慢查询优化

  > 开启long_query_time、log-queries-not-using-indexs、show_query_log
  > 使用慢查询功能，获取查询时间较长的sql`show variables like "%slow_query%";`
  > 使用explain命令查询问题SQL执行计划
  > 使用show profiles查看问题sql的性能情况
  > 优化sql语句

- join优化原则：

  > 驱动表和小表，减少外层循环次数
  > 为匹配条件增加索引（减少内层表的循环匹配次数）
  > 增大join buffer size大小（一次缓存的数据越多，内层表的扫描次数越少）
  > 减少不必要的字段查询（字段越少， join buffer所缓存的数据就越多）

- in优化：

  > 子查询中结果集较少，主查询数据比较大，并且有索引

- exists优化：

  > 子查询结果较多，主查询数据少

- order by优化：

  > 由max_length_for_sort_data参数决定，排序单条记录字段长度 <=， 用全字段排序，反之用rowID

- **索引优化：(空间换时间， 减少磁盘IO次数)**

  > 使用联合索引进行索引覆盖，避免回表， 5.6 增加了**索引下推**优化
  > 查询中使用最左匹配走最左匹配
  > 联合索引创建原则：使用频繁，区分度高（筛选粒度大）
  > 不要在索引列上做任何计算

#### 2.  查询Mysql使用经验

- [explain](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html)命令

  | 参数          | 含义                       |
  | ------------- | -------------------------- |
  | id            | 表的读取顺序               |
  | select_type   | 数据读取操作的操作类型     |
  | possible_keys | 哪些索引可以使用           |
  | key           | 哪些索引被实际使用         |
  | ref           | 表之间的引用               |
  | rows          | 每张表有多少行被优化器查询 |


- 锁内容查询

  `select * from performance_schema.data_locks\G;`

#### 3. Mysql  同步 Redis方案

- 方案1：通过中间件MQ

- 方案2：[Canal开源技术](https://developer.aliyun.com/article/770496)

  - 功能：

    > 数据库镜像
    > 数据库实时备份
    > 索引构建和实时维护
    > 业务cache(缓存)刷新
    > 带业务逻辑的增量数据处理

  - 原理: (**模仿MySQL主从复制**)

    > canal模拟mysql slave的交互协议，伪装自己为mysql slave，向mysql master发送dump协议
    > mysql master收到dump请求，开始推送binary log给slave（也就是canal）
    > canal解析binary log对象（原始为byte流）
    > 自己设计代码将store中的数据同步写入Redis

  - [`参考：数据同步方案`](https://cloud.tencent.com/developer/article/1805755)

- 方案3：**MySQL触发器+UDF函数实现**

  - 实现原理

    <img src="https://ask.qcloudimg.com/http-save/yehe-1651099/k18oryhej5.png" alt="img" style="zoom:70%;"/>

  - 适用场景：读多写少，并且不存并发写的场景

  - 缺点：MySQL触发器效率低，如果一个表经常被操作，特别损耗性能

- 方案4：**解析MySQL的binlog实现，将数据库中的数据同步到Redis**

  - 原理：基于mysql主从复制原理，解析binlog，然后同步到redis中
  - 缺点：binlog存在Statement/Row/Mixedlevel多种形式，分析binlog实现同步的工作量极大
  
- 方案5：双写策略

  - 同时更新 Redis 和 MySQL，配合事务机制确保一致性。



### 面试题

#### 1. 如何保证事务一致性

#### 2. Mysql间隙锁应用方式

#### 3. 什么是回表？产生回表的情况？如何避免？

#### 4. 哪些情况会[索引失效](https://cloud.tencent.com/developer/article/1992920)情况

> - 不满足最左匹配原则：`where 中没有最左项`
> - 范围查询**之后**的索引字段：`where demo_col > 1 and index_demo=1`
> - 索引字段做运算或使用了函数
> - 避免使用SELECT  * : `不会走索引覆盖`
> - or分割的条件不满足 ： `有一个没索引就都失效`   `or两边加了> he < 范围查询`
> - LIKE查询 %开头
> - 参数类型与字段类型不匹配，导致类型发生了隐式转换，索引失效：`int类型加了''变为了字符串`
> - 两个列做比较
> - is not null 不走索引：`is null时可以走索引`
> - 查询条件是字符串使用 != 或 <>可能会不走： `id != 条件会走`
> - 查询条件使用not in时，普通索引索引失效：`如果是主键则走索引`
> - order by 或 limit 未索引覆盖时可能会失效：`索引覆盖可以走`

#### 5. 都有哪些情况会产生死锁

> - [出现死锁的间隙锁](https://blog.csdn.net/tianya_lu/article/details/112562018)：  
>   现象：高并发下，系统老是出现insert死锁 ，主要集中在同一个事务中先delete 后 insert的情况下  
>   原因：数据量比较大的情况下，扫描索引发现数据不存在，delete则会获取间隙锁，以该条数据为界向左或向右构建区间并锁住数据。
>   解决办法：修改取消间隙锁参数=true 或者 修改代码逻辑尽量不去删除不存在的记录

#### 6.100万条数据导入到一个excel里应该怎么做

